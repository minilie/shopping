Ôr@Ÿªassertions¤code´customTransformCache¬dependencies¢id¤meta±moduleSideEffects¬originalCode±originalSourcemap«resolvedIds®sourcemapChainµsyntheticNamedExportsµtransformDependencies®transformFiles¨cacheAstÔrAÚ6f/*
 * Copyright (c) 2022-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import DeepTypeUtils from './DeepTypeUtils';
function assertDeepEquals(actualValue, expected) {
    let result = eq(actualValue, expected[0]);
    let msg = logMsg(actualValue, expected[0]);
    return {
        pass: result,
        message: msg
    };
}

function getMapLog(item) {
    let valueStr = '';
    let keyValue = '';
    if (item.length > 1) {
        let key = item[0];
        let value = item[1];
        if (value !== value) {
            valueStr = value;
        } else {
            valueStr = JSON.stringify(value);
        }
        keyValue = JSON.stringify(key);
    }
    return '[' + keyValue + ',' + valueStr + ']';
}

function getArrayLog(item) {
    // NAN
    if (item !== item) {
        return item;
    }
    if (item === undefined) {
        return 'undefined';
    }
    return JSON.stringify(item);
}


function getCollectionLog(data) {
    // è·å–açš„å¯¹è±¡åç§°
    let finallyResult = '';
    const aClassName = Object.prototype.toString.call(data);
    if (aClassName === '[object Map]') {
        let result = Array.from(data);
        finallyResult = result.flatMap((item) => {
            return getMapLog(item);
        });
    }
    if (aClassName === '[object Set]') {
        let setArray = Array.from(data);
        finallyResult = setArray.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    if (aClassName === '[object Array]') {
        finallyResult = data.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    return finallyResult;
}

function getActualValueLog(actualValue) {
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(actualValue);
    let actualMsg = '';
    if (aClassName === '[object Function]') {
        actualMsg = 'actualValue Function';
    } else if (aClassName === '[object Promise]') {
        actualMsg = 'actualValue Promise';
    } else if (aClassName === '[object Map]') {
        let finallyResult = getCollectionLog(actualValue);
        actualMsg = '[' + finallyResult + ']';
    } else if (aClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object RegExp]') {
        actualMsg = JSON.stringify(actualValue.source.replace('\\', ''));
    } else if (aClassName === '[object BigInt]') {
        actualMsg = actualValue;
    } else if (aClassName === '[object Error]') {
        actualMsg = actualValue.message;
    } else if (aClassName === '[object ArrayBuffer]') {
        actualMsg = actualValue.byteLength;
    }
    else {
        // NAN
        if (actualValue !== actualValue) {
            actualMsg = actualValue.toString();
        } else {
            actualMsg = JSON.stringify(actualValue);
        }
    }
    return actualMsg;
}

function getExpectedLog(expected) {
    const bClassName = Object.prototype.toString.call(expected);
    let expectMsg = '';
    if (bClassName === '[object Function]') {
        expectMsg = 'expected Function';
    } else if (bClassName === '[object Promise]') {
        expectMsg = 'expected Promise';
    } else if (bClassName === '[object Map]') {
        let finallyResult = getCollectionLog(expected);
        expectMsg = '[' + finallyResult + ']';
    } else if (bClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object RegExp]') {
        expectMsg = JSON.stringify(expected.source.replace('\\', ''));
    } else if (bClassName === '[object BigInt]') {
        expectMsg = expected;
    } else if (bClassName === '[object Error]') {
        expectMsg = expected.message;
    } else if (bClassName === '[object ArrayBuffer]') {
        expectMsg = expected.byteLength;
    }
    else {
        // NAN
        if (expected !== expected) {
            expectMsg = expected.toString();
        } else {
            expectMsg = JSON.stringify(expected);
        }
    }
    return expectMsg;
}

/**
 * è·å–å¤±è´¥æ˜¾ç¤ºæ—¥å¿—
 * @param actualValue å®é™…å¯¹è±¡
 * @param expected æœŸå¾…æ¯”è¾ƒå¯¹è±¡
 */
function logMsg(actualValue, expected) {
    // è·å–açš„å¯¹è±¡åç§°
    let actualMsg = getActualValueLog(actualValue);
    let expectMsg = getExpectedLog(expected);

    return 'expect ' + actualMsg + ' deep equals ' + expectMsg;
}

function eq(a, b) {
    let result = true;

    if (a === b) {
        result = a !== 0 || 1 / a === 1 / b;
        return result;
    }

    if (a === null || b === null) {
        result = a === b;
        return result;
    }
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¸åŒç±»å‹ä¸åŒå¯¹è±¡
    if (aClassName !== bClassName) {
        return false;
    }
    if (aClassName === '[object String]' || aClassName === '[object Number]' || aClassName === '[object Date]' ||
        aClassName === '[object Boolean]' || aClassName === '[object ArrayBuffer]' ||
        aClassName === '[object RegExp]' || aClassName === '[object Error]') {
        result = isEqualSampleObj(a, b);
        return result;
    }

    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    if (DeepTypeUtils.isDomNode(a) || DeepTypeUtils.isPromise(a) || DeepTypeUtils.isFunction(a)) {
        result = isEqualNodeOrPromiseOrFunction(a, b);
        return result;
    }

    if (aClassName === '[object Array]' || aClassName === '[object Map]' || aClassName === '[object Set]') {
        result = isEqualCollection(a, b);
        return result;
    }

    result = isEqualObj(a, b);
    return result;
}

function isEqualNodeOrPromiseOrFunction(a, b) {
    let equalNodeOrPromiseOrFunction = true;
    if (DeepTypeUtils.isDomNode(a) && DeepTypeUtils.isDomNode(b)) {
        const aIsDomNode = DeepTypeUtils.isDomNode(a);
        const bIsDomNode = DeepTypeUtils.isDomNode(b);
        if (aIsDomNode && bIsDomNode) {
            // At first try to use DOM3 method isEqualNode
            equalNodeOrPromiseOrFunction = a.isEqualNode(b);
            return equalNodeOrPromiseOrFunction;
        }
        if (aIsDomNode || bIsDomNode) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }

    if (DeepTypeUtils.isPromise(a) && DeepTypeUtils.isPromise(b)) {
        const aIsPromise = DeepTypeUtils.isPromise(a);
        const bIsPromise = DeepTypeUtils.isPromise(b);
        // ä¿©ä¸ªPromiseå¯¹è±¡
        if (aIsPromise && bIsPromise) {
            equalNodeOrPromiseOrFunction = a === b;
            return a === b;
        }
    }
    if (DeepTypeUtils.isFunction(a) && DeepTypeUtils.isFunction(b)) {
        // ä¿©ä¸ªå‡½æ•°å¯¹è±¡
        const aCtor = a.constructor,
            bCtor = b.constructor;
        if (
            aCtor !== bCtor &&
            DeepTypeUtils.isFunction(aCtor) &&
            DeepTypeUtils.isFunction(bCtor) &&
                a instanceof aCtor &&
                b instanceof bCtor &&
                !(aCtor instanceof aCtor && bCtor instanceof bCtor)
        ) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }
    return equalNodeOrPromiseOrFunction;
}

function isEqualCollection(a, b) {
    let equalCollection = true;
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // éƒ½æ˜¯æ•°ç»„
    if (aClassName === '[object Array]') {
        equalCollection = isEqualArray(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Map
    if (DeepTypeUtils.isMap(a) && DeepTypeUtils.isMap(b)) {
        equalCollection = isEqualMap(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Set
    if (DeepTypeUtils.isSet(a) && DeepTypeUtils.isSet(b)) {
        equalCollection = isEqualSet(a, b);
        return equalCollection;
    }

    return true;
}

function isEqualSampleObj(a, b) {
    let equalSampleObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¿©ä¸ªstringå¯¹è±¡
    if (aClassName === '[object String]') {
        equalSampleObj = a === String(b);
        return equalSampleObj;
    }
    // ä¿©ä¸ªNumberå¯¹è±¡
    if (aClassName === '[object Number]') {
        // NAN
        if (a !== a && b !== b) {
            return a === b;
        }
        equalSampleObj = a !== +a ? b !== +b : a === 0 && b === 0 ? 1 / a === 1 / b : a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªDateå¯¹è±¡/ booleanå¯¹è±¡
    if (aClassName === '[object Date]' || aClassName === '[object Boolean]') {
        equalSampleObj = +a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªArrayBuffer
    if (aClassName === '[object ArrayBuffer]') {
        equalSampleObj = eq(new Uint8Array(a), new Uint8Array(b));
        return equalSampleObj;
    }

    // æ­£åˆ™è¡¨è¾¾å¼
    if (aClassName === '[object RegExp]') {
        return (
            a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
        );
    }

    if (a instanceof Error && b instanceof Error) {
        equalSampleObj = a.message === b.message;
        return equalSampleObj;
    }

    return equalSampleObj;
}

function isEqualObj(a, b) {
    let equalObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    const aKeys = DeepTypeUtils.keys(a, aClassName === '[object Array]');
    let size = aKeys.length;

    // ä¿©ä¸ªå¯¹è±¡å±æ€§é•¿åº¦ä¸ä¸€è‡´ï¼Œ ä¿©å¯¹è±¡ä¸ç›¸åŒ
    if (DeepTypeUtils.keys(b, bClassName === '[object Array]').length !== size) {
        return false;
    }

    // ä¿©å¯¹è±¡å±æ€§æ•°é‡ç›¸åŒï¼Œ é€’å½’æ¯”è¾ƒæ¯ä¸ªå±æ€§å€¼å¾—å€¼
    for (const key of aKeys) {
        // b æ²¡æœ‰ key å±æ€§
        if (!DeepTypeUtils.has(b, key)) {
            equalObj = false;
            continue;
        }
        if (!eq(a[key], b[key])) {
            equalObj = false;
        }
    }
    return equalObj;
}

function isEqualArray(a, b) {
    let equalArray = true;
    const aLength = a.length;
    const bLength = b.length;
    if (aLength !== bLength) {
        // æ•°ç»„é•¿åº¦ä¸åŒï¼Œä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡
        return false;
    }
    for (let i = 0; i < aLength || i < bLength; i++) {
        // é€’å½’æ¯ä¸€ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒ
        equalArray = eq(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0) && equalArray;
    }
    return equalArray;
}

function isEqualMap(a, b) {
    let equalMap = true;
    if (a.size !== b.size) {
        return false;
    }
    const keysA = [];
    const keysB = [];
    a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
    });
    b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
    });
    const mapKeys = [keysA, keysB];
    const cmpKeys = [keysB, keysA];
    for (let i = 0; equalMap && i < mapKeys.length; i++) {
        const mapIter = mapKeys[i];
        const cmpIter = cmpKeys[i];

        for (let j = 0; equalMap && j < mapIter.length; j++) {
            const mapKey = mapIter[j];
            const cmpKey = cmpIter[j];
            const mapValueA = a.get(mapKey);
            let mapValueB;
            if (eq(mapKey, cmpKey)) {
                mapValueB = b.get(cmpKey);
            } else {
                mapValueB = b.get(mapKey);
            }
            equalMap = eq(mapValueA, mapValueB);
        }
    }
    return equalMap;
}

function isEqualSet(a, b) {
    let equalSet = true;
    if (a.size !== b.size) {
        return false;
    }
    const valuesA = [];
    a.forEach(function(valueA) {
        valuesA.push(valueA);
    });
    const valuesB = [];
    b.forEach(function(valueB) {
        valuesB.push(valueB);
    });
    const setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
    for (let i = 0; equalSet && i < setPairs.length; i++) {
        const baseValues = setPairs[i][0];
        const otherValues = setPairs[i][1];
        for (const baseValue of baseValues) {
            let found = false;
            for (let j = 0; !found && j < otherValues.length; j++) {
                const otherValue = otherValues[j];
                // æ·±åº¦æ¯”è¾ƒå¯¹è±¡
                found = eq(baseValue, otherValue);
            }
            equalSet = equalSet && found;
        }
    }
    return equalSet;
}

export default assertDeepEquals;
Â‘Ù€G:\harmony\qimo2\oh_modules\.ohpm\@ohos+hypium@1.0.24\oh_modules\@ohos\hypium\src\main\module\assert\deepEquals\DeepTypeUtils.jsÙƒG:\harmony\qimo2\oh_modules\.ohpm\@ohos+hypium@1.0.24\oh_modules\@ohos\hypium\src\main\module\assert\deepEquals\assertDeepEquals.jsÔrB˜±isLocalDependency¯isNodeEntryFile§pkgPath§pkgNameªpkgVersion±belongProjectPath±dependencyPkgInfo¨commonjsÂÂÙMG:\harmony\qimo2\oh_modules\.ohpm\@ohos+hypium@1.0.24\oh_modules\@ohos\hypium¬@ohos/hypium¦1.0.24°G:\harmony\qimo2ÔrC’§pkgNameªpkgVersion¬@ohos/hypium¦1.0.24ÔrD’°hasDefaultExportªisCommonJSÃÂÃÚ6f/*
 * Copyright (c) 2022-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import DeepTypeUtils from './DeepTypeUtils';
function assertDeepEquals(actualValue, expected) {
    let result = eq(actualValue, expected[0]);
    let msg = logMsg(actualValue, expected[0]);
    return {
        pass: result,
        message: msg
    };
}

function getMapLog(item) {
    let valueStr = '';
    let keyValue = '';
    if (item.length > 1) {
        let key = item[0];
        let value = item[1];
        if (value !== value) {
            valueStr = value;
        } else {
            valueStr = JSON.stringify(value);
        }
        keyValue = JSON.stringify(key);
    }
    return '[' + keyValue + ',' + valueStr + ']';
}

function getArrayLog(item) {
    // NAN
    if (item !== item) {
        return item;
    }
    if (item === undefined) {
        return 'undefined';
    }
    return JSON.stringify(item);
}


function getCollectionLog(data) {
    // è·å–açš„å¯¹è±¡åç§°
    let finallyResult = '';
    const aClassName = Object.prototype.toString.call(data);
    if (aClassName === '[object Map]') {
        let result = Array.from(data);
        finallyResult = result.flatMap((item) => {
            return getMapLog(item);
        });
    }
    if (aClassName === '[object Set]') {
        let setArray = Array.from(data);
        finallyResult = setArray.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    if (aClassName === '[object Array]') {
        finallyResult = data.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    return finallyResult;
}

function getActualValueLog(actualValue) {
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(actualValue);
    let actualMsg = '';
    if (aClassName === '[object Function]') {
        actualMsg = 'actualValue Function';
    } else if (aClassName === '[object Promise]') {
        actualMsg = 'actualValue Promise';
    } else if (aClassName === '[object Map]') {
        let finallyResult = getCollectionLog(actualValue);
        actualMsg = '[' + finallyResult + ']';
    } else if (aClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object RegExp]') {
        actualMsg = JSON.stringify(actualValue.source.replace('\\', ''));
    } else if (aClassName === '[object BigInt]') {
        actualMsg = actualValue;
    } else if (aClassName === '[object Error]') {
        actualMsg = actualValue.message;
    } else if (aClassName === '[object ArrayBuffer]') {
        actualMsg = actualValue.byteLength;
    }
    else {
        // NAN
        if (actualValue !== actualValue) {
            actualMsg = actualValue.toString();
        } else {
            actualMsg = JSON.stringify(actualValue);
        }
    }
    return actualMsg;
}

function getExpectedLog(expected) {
    const bClassName = Object.prototype.toString.call(expected);
    let expectMsg = '';
    if (bClassName === '[object Function]') {
        expectMsg = 'expected Function';
    } else if (bClassName === '[object Promise]') {
        expectMsg = 'expected Promise';
    } else if (bClassName === '[object Map]') {
        let finallyResult = getCollectionLog(expected);
        expectMsg = '[' + finallyResult + ']';
    } else if (bClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object RegExp]') {
        expectMsg = JSON.stringify(expected.source.replace('\\', ''));
    } else if (bClassName === '[object BigInt]') {
        expectMsg = expected;
    } else if (bClassName === '[object Error]') {
        expectMsg = expected.message;
    } else if (bClassName === '[object ArrayBuffer]') {
        expectMsg = expected.byteLength;
    }
    else {
        // NAN
        if (expected !== expected) {
            expectMsg = expected.toString();
        } else {
            expectMsg = JSON.stringify(expected);
        }
    }
    return expectMsg;
}

/**
 * è·å–å¤±è´¥æ˜¾ç¤ºæ—¥å¿—
 * @param actualValue å®é™…å¯¹è±¡
 * @param expected æœŸå¾…æ¯”è¾ƒå¯¹è±¡
 */
function logMsg(actualValue, expected) {
    // è·å–açš„å¯¹è±¡åç§°
    let actualMsg = getActualValueLog(actualValue);
    let expectMsg = getExpectedLog(expected);

    return 'expect ' + actualMsg + ' deep equals ' + expectMsg;
}

function eq(a, b) {
    let result = true;

    if (a === b) {
        result = a !== 0 || 1 / a === 1 / b;
        return result;
    }

    if (a === null || b === null) {
        result = a === b;
        return result;
    }
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¸åŒç±»å‹ä¸åŒå¯¹è±¡
    if (aClassName !== bClassName) {
        return false;
    }
    if (aClassName === '[object String]' || aClassName === '[object Number]' || aClassName === '[object Date]' ||
        aClassName === '[object Boolean]' || aClassName === '[object ArrayBuffer]' ||
        aClassName === '[object RegExp]' || aClassName === '[object Error]') {
        result = isEqualSampleObj(a, b);
        return result;
    }

    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    if (DeepTypeUtils.isDomNode(a) || DeepTypeUtils.isPromise(a) || DeepTypeUtils.isFunction(a)) {
        result = isEqualNodeOrPromiseOrFunction(a, b);
        return result;
    }

    if (aClassName === '[object Array]' || aClassName === '[object Map]' || aClassName === '[object Set]') {
        result = isEqualCollection(a, b);
        return result;
    }

    result = isEqualObj(a, b);
    return result;
}

function isEqualNodeOrPromiseOrFunction(a, b) {
    let equalNodeOrPromiseOrFunction = true;
    if (DeepTypeUtils.isDomNode(a) && DeepTypeUtils.isDomNode(b)) {
        const aIsDomNode = DeepTypeUtils.isDomNode(a);
        const bIsDomNode = DeepTypeUtils.isDomNode(b);
        if (aIsDomNode && bIsDomNode) {
            // At first try to use DOM3 method isEqualNode
            equalNodeOrPromiseOrFunction = a.isEqualNode(b);
            return equalNodeOrPromiseOrFunction;
        }
        if (aIsDomNode || bIsDomNode) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }

    if (DeepTypeUtils.isPromise(a) && DeepTypeUtils.isPromise(b)) {
        const aIsPromise = DeepTypeUtils.isPromise(a);
        const bIsPromise = DeepTypeUtils.isPromise(b);
        // ä¿©ä¸ªPromiseå¯¹è±¡
        if (aIsPromise && bIsPromise) {
            equalNodeOrPromiseOrFunction = a === b;
            return a === b;
        }
    }
    if (DeepTypeUtils.isFunction(a) && DeepTypeUtils.isFunction(b)) {
        // ä¿©ä¸ªå‡½æ•°å¯¹è±¡
        const aCtor = a.constructor,
            bCtor = b.constructor;
        if (
            aCtor !== bCtor &&
            DeepTypeUtils.isFunction(aCtor) &&
            DeepTypeUtils.isFunction(bCtor) &&
                a instanceof aCtor &&
                b instanceof bCtor &&
                !(aCtor instanceof aCtor && bCtor instanceof bCtor)
        ) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }
    return equalNodeOrPromiseOrFunction;
}

function isEqualCollection(a, b) {
    let equalCollection = true;
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // éƒ½æ˜¯æ•°ç»„
    if (aClassName === '[object Array]') {
        equalCollection = isEqualArray(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Map
    if (DeepTypeUtils.isMap(a) && DeepTypeUtils.isMap(b)) {
        equalCollection = isEqualMap(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Set
    if (DeepTypeUtils.isSet(a) && DeepTypeUtils.isSet(b)) {
        equalCollection = isEqualSet(a, b);
        return equalCollection;
    }

    return true;
}

function isEqualSampleObj(a, b) {
    let equalSampleObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¿©ä¸ªstringå¯¹è±¡
    if (aClassName === '[object String]') {
        equalSampleObj = a === String(b);
        return equalSampleObj;
    }
    // ä¿©ä¸ªNumberå¯¹è±¡
    if (aClassName === '[object Number]') {
        // NAN
        if (a !== a && b !== b) {
            return a === b;
        }
        equalSampleObj = a !== +a ? b !== +b : a === 0 && b === 0 ? 1 / a === 1 / b : a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªDateå¯¹è±¡/ booleanå¯¹è±¡
    if (aClassName === '[object Date]' || aClassName === '[object Boolean]') {
        equalSampleObj = +a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªArrayBuffer
    if (aClassName === '[object ArrayBuffer]') {
        equalSampleObj = eq(new Uint8Array(a), new Uint8Array(b));
        return equalSampleObj;
    }

    // æ­£åˆ™è¡¨è¾¾å¼
    if (aClassName === '[object RegExp]') {
        return (
            a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
        );
    }

    if (a instanceof Error && b instanceof Error) {
        equalSampleObj = a.message === b.message;
        return equalSampleObj;
    }

    return equalSampleObj;
}

function isEqualObj(a, b) {
    let equalObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    const aKeys = DeepTypeUtils.keys(a, aClassName === '[object Array]');
    let size = aKeys.length;

    // ä¿©ä¸ªå¯¹è±¡å±æ€§é•¿åº¦ä¸ä¸€è‡´ï¼Œ ä¿©å¯¹è±¡ä¸ç›¸åŒ
    if (DeepTypeUtils.keys(b, bClassName === '[object Array]').length !== size) {
        return false;
    }

    // ä¿©å¯¹è±¡å±æ€§æ•°é‡ç›¸åŒï¼Œ é€’å½’æ¯”è¾ƒæ¯ä¸ªå±æ€§å€¼å¾—å€¼
    for (const key of aKeys) {
        // b æ²¡æœ‰ key å±æ€§
        if (!DeepTypeUtils.has(b, key)) {
            equalObj = false;
            continue;
        }
        if (!eq(a[key], b[key])) {
            equalObj = false;
        }
    }
    return equalObj;
}

function isEqualArray(a, b) {
    let equalArray = true;
    const aLength = a.length;
    const bLength = b.length;
    if (aLength !== bLength) {
        // æ•°ç»„é•¿åº¦ä¸åŒï¼Œä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡
        return false;
    }
    for (let i = 0; i < aLength || i < bLength; i++) {
        // é€’å½’æ¯ä¸€ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒ
        equalArray = eq(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0) && equalArray;
    }
    return equalArray;
}

function isEqualMap(a, b) {
    let equalMap = true;
    if (a.size !== b.size) {
        return false;
    }
    const keysA = [];
    const keysB = [];
    a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
    });
    b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
    });
    const mapKeys = [keysA, keysB];
    const cmpKeys = [keysB, keysA];
    for (let i = 0; equalMap && i < mapKeys.length; i++) {
        const mapIter = mapKeys[i];
        const cmpIter = cmpKeys[i];

        for (let j = 0; equalMap && j < mapIter.length; j++) {
            const mapKey = mapIter[j];
            const cmpKey = cmpIter[j];
            const mapValueA = a.get(mapKey);
            let mapValueB;
            if (eq(mapKey, cmpKey)) {
                mapValueB = b.get(cmpKey);
            } else {
                mapValueB = b.get(mapKey);
            }
            equalMap = eq(mapValueA, mapValueB);
        }
    }
    return equalMap;
}

function isEqualSet(a, b) {
    let equalSet = true;
    if (a.size !== b.size) {
        return false;
    }
    const valuesA = [];
    a.forEach(function(valueA) {
        valuesA.push(valueA);
    });
    const valuesB = [];
    b.forEach(function(valueB) {
        valuesB.push(valueB);
    });
    const setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
    for (let i = 0; equalSet && i < setPairs.length; i++) {
        const baseValues = setPairs[i][0];
        const otherValues = setPairs[i][1];
        for (const baseValue of baseValues) {
            let found = false;
            for (let j = 0; !found && j < otherValues.length; j++) {
                const otherValue = otherValues[j];
                // æ·±åº¦æ¯”è¾ƒå¯¹è±¡
                found = eq(baseValue, otherValue);
            }
            equalSet = equalSet && found;
        }
    }
    return equalSet;
}

export default assertDeepEquals;
ÔrE•§version¨mappings¥names§sources®sourcesContentÜ²‘”    ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”  	 ‘”  
 ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”    ‘”  ! ‘”  " ‘”  # ‘”  $ ‘”  % ‘”  & ‘”  ' ‘”  ( ‘”  ) ‘”  * ‘”  + ‘”  , ‘”  - ‘”  . ‘”  / ‘”  0 ‘”  1 ‘”  2 ‘”  3 ‘”  4 ‘”  5 ‘”  6 ‘”  7 ‘”  8 ‘”  9 ‘”  : ‘”  ; ‘”  < ‘”  = ‘”  > ‘”  ? ‘”  Ì@ ‘”  ÌA ‘”  ÌB ‘”  ÌC ‘”  ÌD ‘”  ÌE ‘”  ÌF ‘”  ÌG ‘”  ÌH ‘”  ÌI ‘”  ÌJ ‘”  ÌK ‘”  ÌL ‘”  ÌM ‘”  ÌN ‘”  ÌO ‘”  ÌP ‘”  ÌQ ‘”  ÌR ‘”  ÌS ‘”  ÌT ‘”  ÌU ‘”  ÌV ‘”  ÌW ‘”  ÌX ‘”  ÌY ‘”  ÌZ ‘”  Ì[ ‘”  Ì\ ‘”  Ì] ‘”  Ì^ ‘”  Ì_ ‘”  Ì` ‘”  Ìa ‘”  Ìb ‘”  Ìc ‘”  Ìd ‘”  Ìe ‘”  Ìf ‘”  Ìg ‘”  Ìh ‘”  Ìi ‘”  Ìj ‘”  Ìk ‘”  Ìl ‘”  Ìm ‘”  Ìn ‘”  Ìo ‘”  Ìp ‘”  Ìq ‘”  Ìr ‘”  Ìs ‘”  Ìt ‘”  Ìu ‘”  Ìv ‘”  Ìw ‘”  Ìx ‘”  Ìy ‘”  Ìz ‘”  Ì{ ‘”  Ì| ‘”  Ì} ‘”  Ì~ ‘”  Ì ‘”  Ì€ ‘”  Ì ‘”  Ì‚ ‘”  Ìƒ ‘”  Ì„ ‘”  Ì… ‘”  Ì† ‘”  Ì‡ ‘”  Ìˆ ‘”  Ì‰ ‘”  ÌŠ ‘”  Ì‹ ‘”  ÌŒ ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì‘ ‘”  Ì’ ‘”  Ì“ ‘”  Ì” ‘”  Ì• ‘”  Ì– ‘”  Ì— ‘”  Ì˜ ‘”  Ì™ ‘”  Ìš ‘”  Ì› ‘”  Ìœ ‘”  Ì ‘”  Ì ‘”  ÌŸ ‘”  Ì  ‘”  Ì¡ ‘”  Ì¢ ‘”  Ì£ ‘”  Ì¤ ‘”  Ì¥ ‘”  Ì¦ ‘”  Ì§ ‘”  Ì¨ ‘”  Ì© ‘”  Ìª ‘”  Ì« ‘”  Ì¬ ‘”  Ì­ ‘”  Ì® ‘”  Ì¯ ‘”  Ì° ‘”  Ì± ‘”  Ì² ‘”  Ì³ ‘”  Ì´ ‘”  Ìµ ‘”  Ì¶ ‘”  Ì· ‘”  Ì¸ ‘”  Ì¹ ‘”  Ìº ‘”  Ì» ‘”  Ì¼ ‘”  Ì½ ‘”  Ì¾ ‘”  Ì¿ ‘”  ÌÀ ‘”  ÌÁ ‘”  ÌÂ ‘”  ÌÃ ‘”  ÌÄ ‘”  ÌÅ ‘”  ÌÆ ‘”  ÌÇ ‘”  ÌÈ ‘”  ÌÉ ‘”  ÌÊ ‘”  ÌË ‘”  ÌÌ ‘”  ÌÍ ‘”  ÌÎ ‘”  ÌÏ ‘”  ÌĞ ‘”  ÌÑ ‘”  ÌÒ ‘”  ÌÓ ‘”  ÌÔ ‘”  ÌÕ ‘”  ÌÖ ‘”  Ì× ‘”  ÌØ ‘”  ÌÙ ‘”  ÌÚ ‘”  ÌÛ ‘”  ÌÜ ‘”  Ìİ ‘”  ÌŞ ‘”  Ìß ‘”  Ìà ‘”  Ìá ‘”  Ìâ ‘”  Ìã ‘”  Ìä ‘”  Ìå ‘”  Ìæ ‘”  Ìç ‘”  Ìè ‘”  Ìé ‘”  Ìê ‘”  Ìë ‘”  Ìì ‘”  Ìí ‘”  Ìî ‘”  Ìï ‘”  Ìğ ‘”  Ìñ ‘”  Ìò ‘”  Ìó ‘”  Ìô ‘”  Ìõ ‘”  Ìö ‘”  Ì÷ ‘”  Ìø ‘”  Ìù ‘”  Ìú ‘”  Ìû ‘”  Ìü ‘”  Ìı ‘”  Ìş ‘”  Ìÿ ‘”  Í  ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í	 ‘”  Í
 ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í  ‘”  Í! ‘”  Í" ‘”  Í# ‘”  Í$ ‘”  Í% ‘”  Í& ‘”  Í' ‘”  Í( ‘”  Í) ‘”  Í* ‘”  Í+ ‘”  Í, ‘”  Í- ‘”  Í. ‘”  Í/ ‘”  Í0 ‘”  Í1 ‘”  Í2 ‘”  Í3 ‘”  Í4 ‘”  Í5 ‘”  Í6 ‘”  Í7 ‘”  Í8 ‘”  Í9 ‘”  Í: ‘”  Í; ‘”  Í< ‘”  Í= ‘”  Í> ‘”  Í? ‘”  Í@ ‘”  ÍA ‘”  ÍB ‘”  ÍC ‘”  ÍD ‘”  ÍE ‘”  ÍF ‘”  ÍG ‘”  ÍH ‘”  ÍI ‘”  ÍJ ‘”  ÍK ‘”  ÍL ‘”  ÍM ‘”  ÍN ‘”  ÍO ‘”  ÍP ‘”  ÍQ ‘”  ÍR ‘”  ÍS ‘”  ÍT ‘”  ÍU ‘”  ÍV ‘”  ÍW ‘”  ÍX ‘”  ÍY ‘”  ÍZ ‘”  Í[ ‘”  Í\ ‘”  Í] ‘”  Í^ ‘”  Í_ ‘”  Í` ‘”  Ía ‘”  Íb ‘”  Íc ‘”  Íd ‘”  Íe ‘”  Íf ‘”  Íg ‘”  Íh ‘”  Íi ‘”  Íj ‘”  Ík ‘”  Íl ‘”  Ím ‘”  Ín ‘”  Ío ‘”  Íp ‘”  Íq ‘”  Ír ‘”  Ís ‘”  Ít ‘”  Íu ‘”  Ív ‘”  Íw ‘”  Íx ‘”  Íy ‘”  Íz ‘”  Í{ ‘”  Í| ‘”  Í} ‘”  Í~ ‘”  Í ‘”  Í€ ‘”  Í ‘”  Í‚ ‘”  Íƒ ‘”  Í„ ‘”  Í… ‘”  Í† ‘”  Í‡ ‘”  Íˆ ‘”  Í‰ ‘”  ÍŠ ‘”  Í‹ ‘”  ÍŒ ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í‘ ‘”  Í’ ‘”  Í“ ‘”  Í” ‘”  Í• ‘”  Í– ‘”  Í— ‘”  Í˜ ‘”  Í™ ‘”  Íš ‘”  Í› ‘”  Íœ ‘”  Í ‘”  Í ‘”  ÍŸ ‘”  Í  ‘”  Í¡ ‘”  Í¢ ‘”  Í£ ‘”  Í¤ ‘”  Í¥ ‘”  Í¦ ‘”  Í§ ‘”  Í¨ ‘”  Í© ‘”  Íª ‘”  Í« ‘”  Í¬ ‘”  Í­ ‘”  Í® ‘”  Í¯ ‘”  Í° ‘ÙƒG:\harmony\qimo2\oh_modules\.ohpm\@ohos+hypium@1.0.24\oh_modules\@ohos\hypium\src\main\module\assert\deepEquals\assertDeepEquals.js‘Ú6f/*
 * Copyright (c) 2022-2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import DeepTypeUtils from './DeepTypeUtils';
function assertDeepEquals(actualValue, expected) {
    let result = eq(actualValue, expected[0]);
    let msg = logMsg(actualValue, expected[0]);
    return {
        pass: result,
        message: msg
    };
}

function getMapLog(item) {
    let valueStr = '';
    let keyValue = '';
    if (item.length > 1) {
        let key = item[0];
        let value = item[1];
        if (value !== value) {
            valueStr = value;
        } else {
            valueStr = JSON.stringify(value);
        }
        keyValue = JSON.stringify(key);
    }
    return '[' + keyValue + ',' + valueStr + ']';
}

function getArrayLog(item) {
    // NAN
    if (item !== item) {
        return item;
    }
    if (item === undefined) {
        return 'undefined';
    }
    return JSON.stringify(item);
}


function getCollectionLog(data) {
    // è·å–açš„å¯¹è±¡åç§°
    let finallyResult = '';
    const aClassName = Object.prototype.toString.call(data);
    if (aClassName === '[object Map]') {
        let result = Array.from(data);
        finallyResult = result.flatMap((item) => {
            return getMapLog(item);
        });
    }
    if (aClassName === '[object Set]') {
        let setArray = Array.from(data);
        finallyResult = setArray.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    if (aClassName === '[object Array]') {
        finallyResult = data.flatMap((item) => {
            return getArrayLog(item);
        });
    }
    return finallyResult;
}

function getActualValueLog(actualValue) {
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(actualValue);
    let actualMsg = '';
    if (aClassName === '[object Function]') {
        actualMsg = 'actualValue Function';
    } else if (aClassName === '[object Promise]') {
        actualMsg = 'actualValue Promise';
    } else if (aClassName === '[object Map]') {
        let finallyResult = getCollectionLog(actualValue);
        actualMsg = '[' + finallyResult + ']';
    } else if (aClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(actualValue);
        actualMsg = '[' + flatMapResult + ']';
    } else if (aClassName === '[object RegExp]') {
        actualMsg = JSON.stringify(actualValue.source.replace('\\', ''));
    } else if (aClassName === '[object BigInt]') {
        actualMsg = actualValue;
    } else if (aClassName === '[object Error]') {
        actualMsg = actualValue.message;
    } else if (aClassName === '[object ArrayBuffer]') {
        actualMsg = actualValue.byteLength;
    }
    else {
        // NAN
        if (actualValue !== actualValue) {
            actualMsg = actualValue.toString();
        } else {
            actualMsg = JSON.stringify(actualValue);
        }
    }
    return actualMsg;
}

function getExpectedLog(expected) {
    const bClassName = Object.prototype.toString.call(expected);
    let expectMsg = '';
    if (bClassName === '[object Function]') {
        expectMsg = 'expected Function';
    } else if (bClassName === '[object Promise]') {
        expectMsg = 'expected Promise';
    } else if (bClassName === '[object Map]') {
        let finallyResult = getCollectionLog(expected);
        expectMsg = '[' + finallyResult + ']';
    } else if (bClassName === '[object Set]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object Array]') {
        let flatMapResult = getCollectionLog(expected);
        expectMsg = '[' + flatMapResult + ']';
    } else if (bClassName === '[object RegExp]') {
        expectMsg = JSON.stringify(expected.source.replace('\\', ''));
    } else if (bClassName === '[object BigInt]') {
        expectMsg = expected;
    } else if (bClassName === '[object Error]') {
        expectMsg = expected.message;
    } else if (bClassName === '[object ArrayBuffer]') {
        expectMsg = expected.byteLength;
    }
    else {
        // NAN
        if (expected !== expected) {
            expectMsg = expected.toString();
        } else {
            expectMsg = JSON.stringify(expected);
        }
    }
    return expectMsg;
}

/**
 * è·å–å¤±è´¥æ˜¾ç¤ºæ—¥å¿—
 * @param actualValue å®é™…å¯¹è±¡
 * @param expected æœŸå¾…æ¯”è¾ƒå¯¹è±¡
 */
function logMsg(actualValue, expected) {
    // è·å–açš„å¯¹è±¡åç§°
    let actualMsg = getActualValueLog(actualValue);
    let expectMsg = getExpectedLog(expected);

    return 'expect ' + actualMsg + ' deep equals ' + expectMsg;
}

function eq(a, b) {
    let result = true;

    if (a === b) {
        result = a !== 0 || 1 / a === 1 / b;
        return result;
    }

    if (a === null || b === null) {
        result = a === b;
        return result;
    }
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¸åŒç±»å‹ä¸åŒå¯¹è±¡
    if (aClassName !== bClassName) {
        return false;
    }
    if (aClassName === '[object String]' || aClassName === '[object Number]' || aClassName === '[object Date]' ||
        aClassName === '[object Boolean]' || aClassName === '[object ArrayBuffer]' ||
        aClassName === '[object RegExp]' || aClassName === '[object Error]') {
        result = isEqualSampleObj(a, b);
        return result;
    }

    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    if (DeepTypeUtils.isDomNode(a) || DeepTypeUtils.isPromise(a) || DeepTypeUtils.isFunction(a)) {
        result = isEqualNodeOrPromiseOrFunction(a, b);
        return result;
    }

    if (aClassName === '[object Array]' || aClassName === '[object Map]' || aClassName === '[object Set]') {
        result = isEqualCollection(a, b);
        return result;
    }

    result = isEqualObj(a, b);
    return result;
}

function isEqualNodeOrPromiseOrFunction(a, b) {
    let equalNodeOrPromiseOrFunction = true;
    if (DeepTypeUtils.isDomNode(a) && DeepTypeUtils.isDomNode(b)) {
        const aIsDomNode = DeepTypeUtils.isDomNode(a);
        const bIsDomNode = DeepTypeUtils.isDomNode(b);
        if (aIsDomNode && bIsDomNode) {
            // At first try to use DOM3 method isEqualNode
            equalNodeOrPromiseOrFunction = a.isEqualNode(b);
            return equalNodeOrPromiseOrFunction;
        }
        if (aIsDomNode || bIsDomNode) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }

    if (DeepTypeUtils.isPromise(a) && DeepTypeUtils.isPromise(b)) {
        const aIsPromise = DeepTypeUtils.isPromise(a);
        const bIsPromise = DeepTypeUtils.isPromise(b);
        // ä¿©ä¸ªPromiseå¯¹è±¡
        if (aIsPromise && bIsPromise) {
            equalNodeOrPromiseOrFunction = a === b;
            return a === b;
        }
    }
    if (DeepTypeUtils.isFunction(a) && DeepTypeUtils.isFunction(b)) {
        // ä¿©ä¸ªå‡½æ•°å¯¹è±¡
        const aCtor = a.constructor,
            bCtor = b.constructor;
        if (
            aCtor !== bCtor &&
            DeepTypeUtils.isFunction(aCtor) &&
            DeepTypeUtils.isFunction(bCtor) &&
                a instanceof aCtor &&
                b instanceof bCtor &&
                !(aCtor instanceof aCtor && bCtor instanceof bCtor)
        ) {
            equalNodeOrPromiseOrFunction = false;
            return false;
        }
    }
    return equalNodeOrPromiseOrFunction;
}

function isEqualCollection(a, b) {
    let equalCollection = true;
    // è·å–açš„å¯¹è±¡åç§°
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // éƒ½æ˜¯æ•°ç»„
    if (aClassName === '[object Array]') {
        equalCollection = isEqualArray(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Map
    if (DeepTypeUtils.isMap(a) && DeepTypeUtils.isMap(b)) {
        equalCollection = isEqualMap(a, b);
        return equalCollection;
    }

    // éƒ½æ˜¯Set
    if (DeepTypeUtils.isSet(a) && DeepTypeUtils.isSet(b)) {
        equalCollection = isEqualSet(a, b);
        return equalCollection;
    }

    return true;
}

function isEqualSampleObj(a, b) {
    let equalSampleObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    // ä¿©ä¸ªstringå¯¹è±¡
    if (aClassName === '[object String]') {
        equalSampleObj = a === String(b);
        return equalSampleObj;
    }
    // ä¿©ä¸ªNumberå¯¹è±¡
    if (aClassName === '[object Number]') {
        // NAN
        if (a !== a && b !== b) {
            return a === b;
        }
        equalSampleObj = a !== +a ? b !== +b : a === 0 && b === 0 ? 1 / a === 1 / b : a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªDateå¯¹è±¡/ booleanå¯¹è±¡
    if (aClassName === '[object Date]' || aClassName === '[object Boolean]') {
        equalSampleObj = +a === +b;
        return equalSampleObj;
    }

    // ä¿©ä¸ªArrayBuffer
    if (aClassName === '[object ArrayBuffer]') {
        equalSampleObj = eq(new Uint8Array(a), new Uint8Array(b));
        return equalSampleObj;
    }

    // æ­£åˆ™è¡¨è¾¾å¼
    if (aClassName === '[object RegExp]') {
        return (
            a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
        );
    }

    if (a instanceof Error && b instanceof Error) {
        equalSampleObj = a.message === b.message;
        return equalSampleObj;
    }

    return equalSampleObj;
}

function isEqualObj(a, b) {
    let equalObj = true;
    const aClassName = Object.prototype.toString.call(a);
    const bClassName = Object.prototype.toString.call(b);
    const aKeys = DeepTypeUtils.keys(a, aClassName === '[object Array]');
    let size = aKeys.length;

    // ä¿©ä¸ªå¯¹è±¡å±æ€§é•¿åº¦ä¸ä¸€è‡´ï¼Œ ä¿©å¯¹è±¡ä¸ç›¸åŒ
    if (DeepTypeUtils.keys(b, bClassName === '[object Array]').length !== size) {
        return false;
    }

    // ä¿©å¯¹è±¡å±æ€§æ•°é‡ç›¸åŒï¼Œ é€’å½’æ¯”è¾ƒæ¯ä¸ªå±æ€§å€¼å¾—å€¼
    for (const key of aKeys) {
        // b æ²¡æœ‰ key å±æ€§
        if (!DeepTypeUtils.has(b, key)) {
            equalObj = false;
            continue;
        }
        if (!eq(a[key], b[key])) {
            equalObj = false;
        }
    }
    return equalObj;
}

function isEqualArray(a, b) {
    let equalArray = true;
    const aLength = a.length;
    const bLength = b.length;
    if (aLength !== bLength) {
        // æ•°ç»„é•¿åº¦ä¸åŒï¼Œä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡
        return false;
    }
    for (let i = 0; i < aLength || i < bLength; i++) {
        // é€’å½’æ¯ä¸€ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒ
        equalArray = eq(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0) && equalArray;
    }
    return equalArray;
}

function isEqualMap(a, b) {
    let equalMap = true;
    if (a.size !== b.size) {
        return false;
    }
    const keysA = [];
    const keysB = [];
    a.forEach(function(valueA, keyA) {
        keysA.push(keyA);
    });
    b.forEach(function(valueB, keyB) {
        keysB.push(keyB);
    });
    const mapKeys = [keysA, keysB];
    const cmpKeys = [keysB, keysA];
    for (let i = 0; equalMap && i < mapKeys.length; i++) {
        const mapIter = mapKeys[i];
        const cmpIter = cmpKeys[i];

        for (let j = 0; equalMap && j < mapIter.length; j++) {
            const mapKey = mapIter[j];
            const cmpKey = cmpIter[j];
            const mapValueA = a.get(mapKey);
            let mapValueB;
            if (eq(mapKey, cmpKey)) {
                mapValueB = b.get(cmpKey);
            } else {
                mapValueB = b.get(mapKey);
            }
            equalMap = eq(mapValueA, mapValueB);
        }
    }
    return equalMap;
}

function isEqualSet(a, b) {
    let equalSet = true;
    if (a.size !== b.size) {
        return false;
    }
    const valuesA = [];
    a.forEach(function(valueA) {
        valuesA.push(valueA);
    });
    const valuesB = [];
    b.forEach(function(valueB) {
        valuesB.push(valueB);
    });
    const setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
    for (let i = 0; equalSet && i < setPairs.length; i++) {
        const baseValues = setPairs[i][0];
        const otherValues = setPairs[i][1];
        for (const baseValue of baseValues) {
            let found = false;
            for (let j = 0; !found && j < otherValues.length; j++) {
                const otherValue = otherValues[j];
                // æ·±åº¦æ¯”è¾ƒå¯¹è±¡
                found = eq(baseValue, otherValue);
            }
            equalSet = equalSet && found;
        }
    }
    return equalSet;
}

export default assertDeepEquals;
ÔrF‘¯./DeepTypeUtilsÔrG—ªassertions¨external¢id¤meta±moduleSideEffectsªresolvedByµsyntheticNamedExportsAÂÙ€G:\harmony\qimo2\oh_modules\.ohpm\@ohos+hypium@1.0.24\oh_modules\@ohos\hypium\src\main\module\assert\deepEquals\DeepTypeUtils.jsAÃªoh-resolveÂ‘ÔrH’§missing¦pluginÃ¦genAbcÂÔ  ÔrI”²dynamicImportCache¹exportAllDeclarationCache»exportNamedDeclarationCache«importCache‘ÔrJ•¤type¥start£endªspecifiers¦source±ImportDeclarationÍuÍ¡‘ÔrK”¤type¥start£end¥local¶ImportDefaultSpecifierÍ|Í‰ÔrL”¤type¥start£end¤nameªIdentifierÍ|Í‰­DeepTypeUtilsÔrM•¤type¥start£end¥value£raw§LiteralÍÍ ¯./DeepTypeUtils±'./DeepTypeUtils'